<?php

namespace gueye\blogBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Tools\Pagination\Paginator;

/**
 * ArticleRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ArticleRepository extends EntityRepository
{
	public function getArticles($nombreParPage, $page)
	{
		// On déplace la vérification du numéro de page dans cette méthode
		if ($page < 1) 
		{
			throw new \InvalidArgumentException('L\'argument $page ne peut être inférieur à 1 (valeur : "'.$page.'").');
		}
		$query = $this->createQueryBuilder('a')
					  // On joint sur l'attribut image
					  ->leftJoin('a.image', 'i')
					  ->addSelect('i')
					  // On joint sur l'attribut categories
					  ->leftJoin('a.categories', 'c')
					  ->addSelect('c')
					  ->orderBy('a.date', 'DESC')
					  // On définit l'article à partir duquel commencer la liste
					  ->setFirstResult(($page-1) * $nombreParPage)
					  // Ainsi que le nombre d'articles à afficher
					  ->setMaxResults($nombreParPage);
		// Enfin, on retourne l'objet Paginator correspondant à la requête construite
		// (n'oubliez pas le use correspondant en début de fichier)
		return new Paginator($query);
		return $query->getQuery()
					 ->getResult();
	}

	public function getSelectList()
	{
		$qb = $this->createQueryBuilder('a')
				   ->where('a.publication = 1'); // On filtre sur l'attribut publication
		// Et on retourne simplement le QueryBuilder, et non la Query, attention
		return $qb;
	}

	public function getArticlesMenu()
	{
		// On déplace la vérification du numéro de page dans cette méthode
		$query = $this->createQueryBuilder('a')
					  // On joint sur l'attribut image
					  ->orderBy('a.dateEdition', 'DESC')
					  ->setMaxResults( 5 )
					  ->getQuery();
		return $query->getResult();

	}


	public function getAvecCategories(array $nom_categories)
	{
		$qb = $this->createQueryBuilder('a');
		// On fait une jointure avec l'entité Categorie, avec pour alias « c »
		$qb ->join('a.categories', 'c')
			->where($qb->expr()->in('c.nom', $nom_categories)); // Puis	on filtre sur le nom des catégories à l'aide d'un IN
		// Enfin, on retourne le résultat
		return $qb->getQuery()
				  ->getResult();
	}

	public function myFindAll()
	{
		return $this->createQueryBuilder('a')
					->getQuery()
					->getResult();
	}

	public function myFindOne($id)
	{
		return $this->createQueryBuilder('a')
					->where('a.id = :id')
					->setParameter('id', $id)
					->getQuery()
					->getResult();
	}

	public function findByAuteurAndDate($auteur, $annee)
	{
		// On utilise le QueryBuilder créé par le repository directement pour gagner du temps
		// Plus besoin de faire le select() ni le from() par la suite donc
		$qb = $this->createQueryBuilder('a');
		$qb->where('a.auteur = :auteur')
		   ->setParameter('auteur', $auteur)
		   ->andWhere('a.date < :annee')
		   ->setParameter('annee', $annee)
		   ->orderBy('a.date', 'DESC');
		return $qb->getQuery()
				  ->getResult();
	}

	public function whereCurrentYear(\Doctrine\ORM\QueryBuilder $qb)
	{
		$qb->andWhere('a.date BETWEEN :debut AND :fin')
		   ->setParameter('debut', new \Datetime(date('Y').'-01-01')) 
		// Date entre le 1er janvier de cette année
		   ->setParameter('fin', new \Datetime(date('Y').'-12-31')); 
		// Et le 31 décembre de cette année
		return $qb;
	}

	public function myFind()
	{
		$qb = $this->createQueryBuilder('a');
		// On peut ajouter ce qu'on veut avant
		$qb->where('a.auteur = :auteur')
		   ->setParameter('auteur', 'winzou');
		// On applique notre condition
		$qb = $this->whereCurrentYear($qb);
		// On peut ajouter ce qu'on veut après
		$qb->orderBy('a.date', 'DESC');
		return $qb->getQuery()
		          ->getResult();
	}
}
